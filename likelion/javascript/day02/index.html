<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>javascript - 2일차</title>
    <link rel="stylesheet" href="../../reset.css" />
  </head>
  <body>
    <div class="wrap">
      <h1>javascript 2일차</h1>
      <section>
        <h2>Hello, world!</h2>
        <ol>
          <li>
            내장함수
            <ul>
              <li>사용자와의 상호작용을 하는 빌트인 function</li>
              <li>alert() : 확인</li>
              <li>confirm() : 취소 / 확인</li>
              <li>prompt() : 입력 - html의 input과 같음</li>
            </ul>
          </li>
          <li>
            내장함수 특징
            <ul>
              <li>브라우저(window)가 제공해주는 기능</li>
              <li>window가 생략된 것</li>
              <li>window.alert()</li>
              <li>window.confirm()</li>
              <li>window.prompt()</li>
              <li>window.console.log()</li>
            </ul>
          </li>
          <li>
            스크립트 위치
            <ul>
              <li>인라인 방식 : 유지보수, 재사용성 떨어짐</li>
              <li>내부 방식 : 유지보수 좋지 않음</li>
              <li>외부 방식 : 굿 초이스</li>
            </ul>
          </li>
          <li>
            모던 마크업
            <ul>
              <li>type="text/javascript" : 오래된 버전</li>
              <li>type에 스크립트가 들어가면 예전 것</li>
              <li>type="module" : 요즘 많이 사용하는 방식</li>
            </ul>
          </li>
          <li>
            외부 스크립트
            <ul>
              <li>CDN : Contents Delivery Network</li>
              <li>네트워크상에 올라간 내용을 가져와서 사용하는 것</li>
              <li>
                별도에 파일에 스크립트 작성시 스크립트 다운로드 후 캐시에 저장.
                성능상 이점 있음 !!
              </li>
            </ul>
            <ul>
              <li>
                성능상 이점 : 이전에 해당 사이트에 방문한 경험이 있는 경우
                (처음은 무조건 다운로드 받음)
              </li>
              <li>
                사실 무조건 좋은건 아님. 캐시에 쌓인 데이터를 수정해도 반영이
                안되는 경우가 있음
              </li>
              <li>껐다 키거나 강력 새로고침쓰 갈겨</li>
            </ul>
            <ul>
              <li>그럼 사용자는 강력 새로고침쓰 모르면 ... ?</li>
              <li>
                예전 방식 : style01190938.css (파일명에 시간까지 기록;; - 새로운
                파일로 인식함)
              </li>
              <li>
                요즘 방식 : 번들러가 압축할 때 애초에 파일 이름을 aj4asc1
                이런식으로 해시값을 랜덤으로 만듦 - 사용자는 캐시에 대한 고민
                하지 않아도 됨 따봉 번들러야 고마버~
              </li>
            </ul>
            <ul>
              <li>확인 방법</li>
              <li>개발자도구 - network</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>코드 구조</h2>
        <ol>
          <li>
            문
            <ul>
              <li>
                문 : 값을 반환하지 않음 (for, while, for..in, for..of) = { ... }
              </li>
              <li>식 : 값을 반환함 (삼항식, 이항식, 단항식)</li>
            </ul>
          </li>
          <li>
            세미콜론
            <ul>
              <li>
                '암시적' 세미콜론 : 자바스크립트는 줄바꿈이 생기면 자동으로
                세미콜론을 삽입함
              </li>
              <li>대부분 줄바꿈은 세미콜론으로 인식되지만, 항상은 아님</li>
              <li>
                암시적 : 자스는 암시적으로 변환하는 것이 많은 자유로운 언어 =>
                언제 암시적으로 변하는지 잘 파악해야함
              </li>
              <li>암시적 인터뷰 질문 단골쓰 ~</li>
            </ul>
            <ul>
              <li>
                자스 엔진이 알아서 세미콜론 넣어주겠지? 뒤통수 예시 : 대괄호
                앞에는 세미콜론이 있다고 가정하지 않음 > 단일문 처리
              </li>
              <li>줄바꿈 해도 세미콜론 넣는 것을 권장함 : prettier로 해결</li>
            </ul>
          </li>
          <li>
            주석
            <ul>
              <li>한줄 주석 : 문/식 뒤에도 입력 가능</li>
              <li>
                주석 달기를 두려워마되, 설명용으로 주석을 사용하는 것은 지양
                (변수, 함수이름으로 설명이 되도록)
              </li>
            </ul>
          </li>
          <li>
            주석 관련 vs 확장자
            <ul>
              <li>Comment Divider : 구분 주석 확장자</li>
              <li>Nested Comments 이중 주석 확장자</li>
              <li>Hide Comments : 주석 끄기 확장자 - 남의 코드 볼 때 편리함</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>변수와 상수</h2>
        <ol>
          <li>
            변수
            <ul>
              <li>선언과 할당 구분</li>
              <li>
                single let pattern : let user = 'sozzang', (줄바꿈) age = 100
              </li>
              <li>한 줄에 한 개의 변수 작성하는 것 권장 !</li>
              <li>dot log : 디버깅 편하게 해주는 확장자</li>
            </ul>
          </li>
          <li>
            할당 되지 않은 변수
            <ul>
              <li>참조시 undefined</li>
              <li>호이스팅과 구분필요 ! 호이스팅이 뭔지는 아래에서~</li>
            </ul>
          </li>
          <li>
            객체 중심 방식 vs 함수 중심 방식
            <ul>
              <li>객체 중심 : 어려버</li>
              <li>함수 중심 : 사용 예정 - react hook 관련됨</li>
              <li>
                함수 중심 방식이 함수형 프로그래밍은 아님,,, ~ 무슨 말일까 ?
              </li>
            </ul>
          </li>
          <li>
            변수 명명 규칙
            <ul>
              <li>
                _ : 사용되지 않거나 숨김 프로퍼티인 경우 주로 사용함 (하지만
                lodash 라이브러리일 가능성 있으니 주의)
              </li>
            </ul>
          </li>
          <li>
            상수
            <ul>
              <li>
                1) 코드 실행 전 이미 그 값을 아는 상수 2) 런타임 과정에서
                계산되어 할당 이후 변하지 않는 상수
              </li>
              <li>
                1) 런타임 이전에 값을 알고 있는 경우, 하드 코딩한 값 => 찐상수 =
                대문자 상수 (예시 COLOR_WHITE: #fff;)
              </li>
              <li>(런타임 : 웹브라우저가 코드를 해석하는 시간)</li>
              <li>
                대문자 상수 장점 : 기억하기 쉽고, 오타 확률 적음, 코드 가독성
                증가
              </li>
              <li>
                2) 런타임 이후에 값이 변하지 않는 경우, 동적으로 값 받음 =>
                소문자 상수 (예시 pageLoadTime: .3;)
              </li>
            </ul>
            <ul>
              <li>상수이기 때문에 = 할당 연산자 바로 옆의 값을 못바꿈</li>
              <li>const a = 'hello' : 'hello' 못바꿈</li>
              <li>const b = { ... } : {} 못바꿈, 객체 안의 내용물 변경 가능</li>
              <li>
                객체 값이 바뀌면 위험한거 아녀? b.name.freeze() 해서 동결시킴
              </li>
            </ul>
          </li>
          <li>
            바람직한 변수명
            <ul>
              <li>
                emailFormSubmitButton : 이름이 길어지더라도 1달뒤에 봐도 어떤
                값을 담고 있을지 알아야 함
              </li>
              <li>
                data, value 등은 함수 블럭 안에서는 사용하기도 함(함수
                블럭에서만 유효하기 때문에)
              </li>
              <li>
                name : 이미 정의되어 있는 이름 ! window.name 하면 값이 있음 ;
                몰랐음 ; 그래서 선이 그어지는 것 ~
              </li>
              <li>var name => window.name 도 변경됨</li>
              <li>let name => window.name 은 변경 안됨</li>
              <li>translator : 한글을 영문으로 번역해주는 확장자</li>
              <li>
                여부 관련 변수명 : true, false가 들어가는 경우가 많아서
                관례적으로 is, has로 시작하는 경우가 많음
              </li>
            </ul>
          </li>
          <li>
            참조에 의한 복사 맛보기
            <ul>
              <li>원시값 복사 => 같은 값을 만들어서 복사됨 (원본 따로)</li>
              <li>객체 복사 => 같은 값 복사됨 (원본을 참조)</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>엄격모드 (use strict)</h2>
        <ol>
          <li>
            엄격모드가 뭔디
            <ul>
              <li>
                ES5의 변경사항 대부분이 기본 모드에선 활성화되지 않도록 설계됨 =
                Sloppy Mode
              </li>
              <li>엄격 모드를 사용해야만 변경사항이 활성화됨</li>
              <li>
                스크립트 최상단에 "use strict" => 작성시 모던 방식 (Strict Mode)
              </li>
              <li>주석 제외 코드가 use strict 상단에 있으면 활성화 안됨</li>
              <li>한번 사용하면 절대 취소 못해 !!</li>
            </ul>
          </li>
          <li>
            Sloppy Mode
            <ul>
              <li>모던이 아닌, ES5의 변경점이 적용되지 않은 모드</li>
            </ul>
          </li>
          <li>
            꼭 사용해야해 ... ?
            <ul>
              <li>꼭 안써도돼 ~</li>
              <li>클래스와 모듈을 사용한다면, 자동으로 use strict 적용됨 !</li>
              <li>날 것(공부용)의 환경에서 개발한다면 굳이?</li>
              <li>
                실제 환경(번들러, 모듈)에서 개발한다면 use strict는 기본값임 =
                생략 가능
              </li>
              <li>나중에 보면 모든지 다 use strict이다.</li>
            </ul>
            <ul>
              <li>모듈쓰</li>
              <li>script type="module" 이렇게 작성해서 사용함</li>
              <li>모듈쓰 안에선 this도 window가 아닌 undefined 반환됨</li>
              <li>모듈쓰는 전역을 보호한다잉</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>전역 객체</h2>
        <ol>
          <li>
            같은 말쓰
            <ul>
              <li>browser = window = viewport = global object = 전역 객체</li>
            </ul>
          </li>
          <li>
            브라우저와 노드에서의 전역 객체
            <ul>
              <li>브라우저 전역 = window</li>
              <li>노드 전역 = global</li>
              <li>
                노드 실행하기 : node server/index.js > window is not defined
              </li>
              <li>전역 객체의 이름을 globalThis 표준으로 등록됨 : 2019년</li>
            </ul>
          </li>
          <li>
            전역 객체는 빌트인 함수를 담고 있는 애
            <ul>
              <li>내장함수 : alert 등</li>
            </ul>
          </li>
          <li>
            폴리필
            <ul>
              <li>공간을 메꿀 때 쓰는 솜</li>
              <li>해당 기능이 빵꾸난 익스를 위한 대체 코드 ? ? 같은 느낌</li>
              <li>
                Promise가 없다면 window.promise = ... 하고 직접 기능을 만들어줌
              </li>
            </ul>
          </li>
          <li>
            전역을 오염시키지 말자
            <ul>
              <li>
                var로 변수를 선언하면 전역 객체에 바인딩됨 = 전역을 오염시킴
              </li>
              <li>let, const는 전역(window)에 바인딩 안됨</li>
              <li>
                프로젝트 전체에 필요한 변수라도 전역으로 관리하는 것이 아니라,
                전역 상태관리로 하는 것이 가장 안전함
              </li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>Legacy var (⭐️)</h2>
        <ol>
          <li>
            var의 특징
            <ul>
              <li>
                남이 짠 스크립트 중간 중간에 var가 나오면 그건 괴물이니까 도망쳐
              </li>
            </ul>
          </li>
          <li>
            var : 블록 스코프가 없음
            <ul>
              <li>
                블록 : { ... } = 문(문법) - 앞에 변수 없음 (for, while ...)
              </li>
              <li>객체 : const a = { ... } - 앞에 변수를 받음</li>
              <li>스코프 : 변수의 유효범위, 변수를 확인할 수 있는 유효 범위</li>
              <li>
                블록 스코프 : 블록이 기준이 되어 블록안>밖X 밖>안X, 블록은
                울타리라서 안<>밖으로 넘나들 수 없음
              </li>
              <li>
                var : 울타리 걍 뿌셔 - 블록문 안의 변수가 전역 변수처럼 사용됨
              </li>
              <li>let, const : 울타리 못 넘어 - 전역을 오염시키지 않음</li>
            </ul>
          </li>
          <li>
            var : 함수 스코프에 갇힘
            <ul>
              <li>함수 안에서 할당된 var는 함수 밖에서 참조하지 못함</li>
            </ul>
          </li>
          <li>
            var : 변수의 중복 선언 허용
            <ul>
              <li>
                중복 사용해도, 에러 발생하지 않고 참조하면 마지막으로 할당된
                값이 반환됨
              </li>
            </ul>
          </li>
          <li>
            var : 선언하기 전 사용할 수 있음
            <ul>
              <li>오잉? 레거씌 ~ 바에선 됨</li>
              <li>이유 : 위로 끌어올려진 것처럼(호이스팅) 작동하기 때문에</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>실행 환경 (Execution Context)</h2>
        <ol>
          <li>피그마 참고 <img src="context.png" alt="" /></li>
          <li>
            전역 실행 환경 (Global Execution Context)
            <ul>
              <li>나 : js 파일 완성! 저장 ~</li>
              <li>
                브라우저 : 자스엔진으로 파일을 해석 해야되니까 실행환경 만들어라
              </li>
              <li>
                ㄴ 전역 실행 환경 : 자스가 연결되어 있다면, 최초 1회 실행됨
              </li>
              <li>ㄴ 가장 바깥쪽에 있기 때문에 '전역' 실행 환경이라고 함</li>
              <li>실행 환경 : var는 저기로~ let은 저기로~ (나눔)</li>
            </ul>
          </li>
          <li>
            Lexical Environment : 어휘적 환경 (말로 표현할 수 있는)
            <ul>
              <li>전역 실행 환경 내에 보이진 않지만 말로 표현 가능한 환경</li>
              <li>
                var : 환경기록장치 > Object Environment > Binding Object(전역
                객체)
              </li>
              <li>
                let, const : 환경기록장치 > Declarative(선언부) Environment >
                let, const
              </li>
              <li>
                함수 : 환경기록장치 > Object Environment > Binding Objett(전역
                객체)
              </li>
              <li>ㄴ 엥 윈도우에 바인딩? 그럼 window.sum() 가능? 가능 ..!</li>
            </ul>
          </li>
          <li>
            Binding Object
            <ul>
              <li>윈도우에 바인딩된 변수는 초기값(undefined)을 할당받음</li>
              <li>ㄴ 개발자는 아~무것도 안해도 undefined 할당받음</li>
              <li>
                선언 이전에 참조 : console.log(a); var a = 10; // undefined :
                호이스팅되어 초기값 할당됨 (10은 할당전)
              </li>
            </ul>
          </li>
          <li>
            Declarative(선언부) Environment
            <ul>
              <li>그 어떠한 값도 할당받지 않음 = 초기값 자체가 없음</li>
              <li>
                선언 이전에 참조 : console.log(a); let a = 10; // x is not
                defined : 너 선언만 했잔; 정의된게 없잔;
              </li>
              <li>
                = Temparol Dead Zone (TDZ) : 임시 사망(사각) 지역 (공식 문서엔
                없음)
              </li>
              <li>
                ㄴ 선언부 환경으로 끌어올려져 초기값 없이 선언만 호이스팅된
                상태, 런타임에 할당문이 실행되기 전
              </li>
            </ul>
          </li>
          <li>
            호이스팅
            <ul>
              <li>
                자바스크립트는 모든 변수(+함수 등의 식별자)의 '선언부'를 찾아서
                코드의 상단으로 끌어올림
              </li>
              <li>할당은 호이스팅에 해당되지 않음</li>
            </ul>
          </li>
        </ol>
      </section>
    </div>
  </body>
</html>
