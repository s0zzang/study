<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>javascript - day6</title>
    <link rel="stylesheet" href="../../reset.css" />
  </head>
  <body>
    <div class="wrap">
      <h1>javascript day6</h1>
      <section>
        <h2>while과 for 반복문</h2>
        <ol>
          <li>
            ‘do…while’ 반복문
            <ul>
              <li>do { 실행문 } while( 조건 )</li>
              <li>조건이 맞지 않아도 최초 1회 무조건 실행</li>
            </ul>
          </li>
          <li>
            defer
            <ul>
              <li>defer 속성이 있는 스크립트를 '백그라운드'에서 다운로드함</li>
              <li>따라서 다운로드 중에도 HTML 파싱이 멈추지 않음</li>
              <li>defer 스크립트 실행은 페이지 구성이 끝날 때까지 지연함</li>
              <li>스크립트 코드보다 아래 작성된 코드도 읽을 수 있음</li>
              <li>
                <code>&lt;script&gt;</code> : html > js > js 실행 > html 다시
                읽어
              </li>
              <li>
                <code>&lt;script defer&gt;</code> : html은 계속 읽으면서 js도
                다운로드해 > html 로딩 다 끝나면 js 실행
              </li>
              <li>실행 순서 : 문서에 추가된 순</li>
            </ul>
            <ul>
              <li>async</li>
              <li>
                async 속성이 있는 스크립트는 defer와 동일하게 '백그라운드'에서
                다운로드함
              </li>
              <li>
                async 스크립트 실행 중에는 HTML 파싱을 멈춤
                <img
                  src="https://media.licdn.com/dms/image/C5112AQFW3cKEhP9AkQ/article-cover_image-shrink_600_2000/0/1520214760879?e=2147483647&v=beta&t=hlxDsKDgQ3eE7lliu-_zEHjalqcl-jn2l54t5WEn5ys"
                  alt=""
                />
              </li>
              <li>
                다른 스크립트들은 async 스크립트를 기다리지 않고 async 스크립트
                역시 기다리지 않음
              </li>
              <li>async 스크립트가 여러 개 있는 경우, 실행 순서가 제각각임</li>
              <li>실행 순서 : 다운로드 끝난 순</li>
            </ul>
          </li>
          <li>
            node
            <ul>
              <li>dom의 세상에서 가장 작은 단위</li>
              <li>
                공백, 주석, 요소, 속성 등이 포함되고 nodeType으로 구분 가능
              </li>
              <li><code>span</code>의 nodeType : 1 (ELEMENT_NODE)</li>
              <li>
                <code>text</code>의 nodeType : 3 (TEXT_NODE) - 개행도 문자로
                해석함
              </li>
              <li><code>주석</code>의 nodeType : 8 (COMMENT_NODE)</li>
              <li><code>docuemnt</code>의 nodeType : 9 (DOCUMENT_NODE)</li>
              <li><code>nextSibling</code> 옆의 노드 찾기</li>
              <li><code>nextElementSibling</code> 옆의 요소 노드 찾기</li>
            </ul>
          </li>
          <li>
            ‘for’ 반복문
            <ul>
              <li>1) 변수 선언(begin)</li>
              <li>2) 조건 확인 (condition)</li>
              <li>3) body 실행</li>
              <li>4) 갱신(step)</li>
            </ul>
            <ul>
              <li>
                <code>for (let i = 0; i < 3; i++)</code>
              </li>
              <li>인라인으로 변수 선언 권장</li>
              <li>
                for문 밖에서 변수를 선언했다면, for문 밖에서도 사용 가능하여
                전역 변수를 오염시킬 수 있음
              </li>
            </ul>
            <ul>
              <li><code>for (; i < 3; i++)</code></li>
              <li>생략 가능하지만 생략하려면 ; 필수 기재</li>
              <li><code>for (;;)</code> 무한 반복</li>
              <li>
                만약 무한 반복을 의도적으로 사용해야 한다면, 더 직관적인 while문
                사용 권장
              </li>
            </ul>
          </li>
          <li>
            반복문 빠져나오기
            <ul>
              <li>break 사용</li>
              <li>삼항 연산자 내에서 break, continue 사용 불가</li>
            </ul>
          </li>
          <li>
            다음 반복으로 넘어가기
            <ul>
              <li>해당 항목만 건너뛰기</li>
              <li>continue 사용</li>
              <li>
                전체 반복문을 멈추지 않고 대신에 현재 실행 중인 이터레이션을
                멈추고 반복문이 다음 이터레이션을 강제로 실행
              </li>
              <li>삼항 연산자 내에서 break, continue 사용 불가</li>
            </ul>
          </li>
          <li>
            'for .. in' 반복문
            <ul>
              <li>객체의 프로퍼티가 있는지 확인할 때 사용</li>
              <li>'in'문 활용법 : <code>console.log('key' in obj)</code></li>
              <li>
                'in'문 단점 : <code>'toString' in obj</code> : true - 조상
                객체(프로토타입)에서 상속받은 키도 확인해서 반환함
              </li>
            </ul>
            <ul>
              <li>
                <code>hasOwnProperty</code>
                프로토타입에서 상속받은 프로퍼티 말고! 오직 내 프로퍼티만 찾는
                방법
              </li>
              <li>
                hasOwnProperty는 보호되지 않음 (례?) : 내장 객체가 사용자에 의해
                변경될 수 있기 때문에
              </li>
              <li>
                <code> Object.prototype.hasOwnProperty</code> 빌려쓰기 :
                오염되지 않은 안전한 hasOwnProperty 기능을 사용하는 방법
              </li>
              <li>
                <code>({}).hasOwnProperty.call(js, key)</code>
                조상이 아니어도 능력 빌려올 수 있음
              </li>
              <li>
                > 새로 만든 {} 이기 때문에 안전하게 사용할 수 있음 (다른데서
                훼손할 가능성이 적음)
              </li>
            </ul>
            <ul>
              <li>
                프로토타입의 많은 프로퍼티 중 nickName만 나오는 이유 :
                nickName만 열거 가능해서(enumerable)
              </li>
              <li>
                열거 가능 여부도 내가 정할 수 있음 (tiger 열거 안되게 설정하는
                방법) <br />
                <code
                  >Ojbect.defineProperty(obj, 'key1', { enumerable:false, value:
                  tiger }</code
                >
              </li>
            </ul>
            <ul>
              <li>헷갈리는 용어 정리</li>
              <li>
                <code>enumerable</code> : 열거 가능한 (코드 차원에서 접근
                가능한지)
              </li>
              <li>
                <code>immutable</code> : 변하지 않는 (리액트 세상에서 짱많이
                씀요 : 리액트는 함부로 값을 수정할 수 없는 규칙이 있어서)
              </li>
              <li><code>iterable</code> : 반복 가능한 (배열 관련)</li>
            </ul>
            <ul>
              <li>
                <code>for..in</code>
                그런데 확인해야 할 게 많다면 반복해서 사용해야겠죠?
              </li>
              <li>in문을 반복적으로 사용하는 것</li>
              <li>객체 순환에 사용 권장 <-> 배열 순환에 사용 지양</li>
              <li>
                순서가 중요한 배열에선, <code>for in</code>으로 작업하면
                순서보장 안되고 성능 다운쓰
              </li>
              <li>배열은 forEach, for, for..of 사용</li>
            </ul>
          </li>
          <li>
            'for .. of' 반복문
            <ul>
              <li>젤 많이 씀</li>
              <li>반복 가능한 요소(iterable)에만 사용이 가능함</li>
              <li>배열의 특징 : 인덱스가 있음, length 존재</li>
              <li>
                유사 배열 : 배열처럼 생겼지만 배열은 아님 | HTMLCollection 등
                짱많음
              </li>
              <li>
                iterable 확인 : 개발자도구 > Symbol(Symbol.iterator)가
                들어있으면 iterable
              </li>
              <li>반복문이기 때문에 continue, break 사용 가능</li>
              <li>
                객체를 순환할 땐 쓸수 없다고 했지만(iterable 하지 않기 때문에),
                사실 많이 씀 (어떻게요? 아래에서 설명~)
              </li>
            </ul>
            <ul>
              <li>객체 순환 시키기 방법 : 배열로 만들기</li>
              <li>
                <code>Object.keys()</code> 객체의 key만 모아서 배열로 만들어줘 ~
              </li>
              <li>
                <code>Object.values()</code> 객체의 value만 모아서 배열로
                만들어줘 ~
              </li>
              <li>
                <code>Object.entries()</code> 객체의 키와 값을 0: 키, 1: 값으로
                묶인 하나의 쌍 배열을 모아서 배열로 만들어줘 ~
              </li>
            </ul>
          </li>
          <li>
            배열용 능력
            <ul>
              <li>forEach, map, filter, reduce 많이 사용함</li>
            </ul>
          </li>
          <li>
            취업 매운맛
            <ul>
              <li>수업에서 진도 안나가도 웬만하면 알아야함 ~ ㅠ</li>
              <li>
                지금 배우는건 유치원생 수준이고 자스 코어 10배 이상 알아야함 ...
              </li>
              <li>타스 알아야함 (요즘엔 jsdoc도 많이 씀)</li>
              <li>연봉이 높은 이유다 ~ 다 알아라 ~</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>함수</h2>
        <ol>
          <li>
            뭔디요
            <ul>
              <li>재사용 가능</li>
            </ul>
          </li>
          <li>
            지역 변수
            <ul>
              <li>함수 안에서만 접근 가능</li>
              <li>전역 실행 환경처럼 함수 실행환경이 만들어지기 때문</li>
            </ul>
          </li>
          <li>
            외부 변수
            <ul>
              <li>함수 밖의 내용은 함수 안에서 건들이지 않는 것이 좋음</li>
              <li>
                외부 변수를 사용하는 방법 대신 지역 변수와 매개변수를 활용
              </li>
            </ul>
          </li>
          <li>
            매개 변수
            <ul>
              <li>= 인자, parameter (인수 X)</li>
              <li>함수 안에서 지역 변수처럼 사용이 가능함</li>
            </ul>
          </li>
          <li>
            기본값
            <ul>
              <li>매개변수에 인수를 전달하지 않으면 undefined가 됨</li>
              <li>
                매개변수에 값이 전달되지 않을 경우를 대비해 기본값을 설정하는 것
              </li>
              <li>
                <code>function showMessage(from, text = "no text given")</code>
              </li>
              <li>
                기본값으로 함수 실행문 가능. 함수에서 반환된 값이 들어갈 것
              </li>
            </ul>
            <ul>
              <li>
                사실 등장한지 얼마 안된 칭구 ~ 원래 사용하던 방법은 아래 2가지
              </li>
              <li>
                <code>if (text === undefined) { text = 'no text given'; }</code>
              </li>
              <li>
                <code>text = text || 'no text given';</code>
              </li>
              <li>
                <code>text = text ?? 'no text given';</code> : text에 falsy한
                값을 의도적으로 넣었을 경우 ?? 사용
              </li>
            </ul>
          </li>
          <li>
            반환값
            <ul>
              <li>
                <code>return</code> : 함수 어디서든 사용 가능하고 사용 즉시 함수
                실행 종료
              </li>
              <li><code>return</code>만 쓰는 것 가능 - 반환값 : undefined</li>
            </ul>
          </li>
          <li>
            함수 이름 짓기
            <ul>
              <li><code>show</code> 무언가를 보여줌</li>
              <li><code>get</code> 무언가를 반환함</li>
              <li><code>calc</code> 무언가를 계산함</li>
              <li><code>create</code> 무언가를 생성함</li>
              <li><code>check</code> 무언가를 확인하고 불린값 반환</li>
            </ul>
            <ul>
              <li>함수는 한 가지의 로직만 처리 (순수 함수)</li>
            </ul>
          </li>
          <li>
            Test Driven Development(TDD)
            <ul>
              <li><code>console.assert(rem(10) === '0.625px')</code></li>
              <li>jest</li>
            </ul>
          </li>
        </ol>
      </section>
    </div>
  </body>
</html>
