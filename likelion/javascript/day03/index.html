<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>javascript - 3일차</title>
  <link rel="stylesheet" href="../../reset.css">
</head>
<body>
  <section class="wrap">
    <h1>javascript 3일차</h1>
    <section>
        <h2>예습</h2>
        <ol>
            <li>함수 내 변수 스코프
                <ul>
                    <li>전역변수를 함수 내에서 값을 변경한 경우 : 전역 변수를 재할당한 것이므로 함수 밖에서도 값이 반영됨</li>
                    <li>전역변수를 함수 내에서 매개변수로 사용하여 값을 변경한 경우 : 전역변수를 매개변수로 '복사'하여 사용하였기 때문에 함수 내에서 값을 변경해도 함수 밖에서 값이 반영되지 않음</li>
                </ul>
            </li>
            <li>값의 복사 vs 참조에 의한 복사
                <ul>
                    <li>값의 복사 : 원시 자료형은 값의 복사를 통해 독립적인 변수를 생성함. 복사된 값을 수정해도 원본값이 변하지 않음</li>
                    <li>참조에 의한 복사 : 객체 자료형은 참조에 의한 복사. 복사된 값을 수정하면 원본 값이 수정됨. 독립적인 값을 가진 객체가 생성된 것이 아니라 원본 객체를 참조하는 것</li>
                </ul>
            </li>
            <li>배열 사용 주의점
                <ul>
                    <li><code>for .. in</code> : 배열보단 객체에 적합한 메서드. 키가 숫자가 아닌 프로퍼티까지 순회할 수 있어 문제 발생 가능성 있음</li>
                </ul>
            </li>
        </ol>
    </section>
    <section>
        <h2>복습</h2>
        <ol>
            <li>조금 특별한 함수
                <ul>
                    <li>변수 : 선언부만 끌어올려짐 (할당 끌어올려지지 않음)</li>
                    <li>함수 : 함수의 이름만 끌어올려지지 않고 함수 본문 자체가 끌어올려짐</li>
                    <li>> 함수 선언 전에 호출 가능 : 진짜 함수가 실행됨 (장점이자 단점)</li>
                </ul>
            </li>
            <li>스코프 체이닝
                <ul>
                    <li>블록문이 아무리 많아져도 블록 밖 변수를 블록 안에서 참조 가능</li>
                </ul>
            </li>
        </ol>
    </section>
    <section>
        <h2>자료형</h2>
        <ol>
            <li>값이란?
                <ul>
                    <li>할당부의 오른쪽 영역</li>
                </ul>
            </li>
            <li>동적 타입 언어
                <ul>
                    <li>자료형이 변경되어도 오류가 나지 않음 = 모든지 다 변경이 가능</li>
                    <li>자스를 정적 타입으로 사용할 수 없나유 ... ? : 타입스크립트로 가능</li>
                </ul>
            </li>
            <li>숫자형
                <ul>
                    <li>정수, 소수 모두 숫자로 퉁침</li>
                    <li>특수 숫자 값도 포함 : <code>Infinity</code>(양의 무한대), <code>-Infinity</code>(음의 무한대), <code>NaN</code>(Not a Number)</li>
                </ul>
                <ul>
                    <li>더하기를 제외한 문자와 숫자의 연산 불가</li>
                    <li><code>문자 + 숫자 = '문자숫자'</code> : 접합 과정을 거쳐 숫자가 문자형으로 변환됨</li>
                    <li>연산이 실패해도 에러를 내는 것이 아니라 <code>NaN</code>만 반환하고 종료됨 ... > 내가 직접 <code>NaN</code>을 찾아야 함</li>
                </ul>
            </li>
            <li><code>BigInt</code>
                <ul>
                    <li><code>Number</code> 원시 값이 안정적으로 나타낼 수 있는 최대치인 <code>2^53 - 1</code>보다 큰 정수를 표현할 수 있는 내장 객체</li>
                    <li>가장 안전한 큰 정수보다 큰 값이 표현되긴 함 : 안전 보장하진 못하지만 계산은 해줌 (하지만 계산 틀렸죠?)</li>
                    <li>안전한 큰 정수보다 더 큰 값을 사용해야할 때 <code>BigInt</code> 사용</li>
                    <li>은행권, 복잡한 암호화 아닌 경우 잘 사용하지 않음</li>
                </ul>
            </li>
            <li>문자형
                <ul>
                    <li>백틱 사용시 표현식 넣을 수 있음</li>
                    <li>백틱 내  표현식 : 보간법 (interpolation)</li>
                </ul>
            </li>
            <li>불린형</li>
            <li><code>null</code> 값
                <ul>
                    <li>존재하지 않는 값, 비어있는 값, 알 수 없는 값</li>
                    <li>개발자가 임의로 값을 비운 것</li>
                    <li><code>typeof null</code> : object (자스 오류)</li>
                </ul>
            </li>
            <li><code>undefined</code> 값
                <ul>
                    <li>값이 할당되지 않은 상태, 엔진 자체에서 할당된 값</li>
                    <li>사용자가 건들지 않은 상태, 값이 있는지 비어있는지도 모름, 정의된 적이 없음</li>
                    <li><code>typeof undeifned</code> : undefined</li>
                </ul>
                <ul>
                    <li>명시적으로 할당하지 않은 의미로 <code>undefined</code> 값을 할당할 순 있지만 권장 X </li>
                    <li>> 개발자가 의도적으로 비운 값은 <code>null</code>을 사용하는 것이 관례</li>
                    <li>ex) 변수 선언은 했지만 값은 할당되지 않은 경우</li>
                </ul>
            </li>
            <li>객체형
                <ul>
                    <li>데이터 컬렉션, 복잡한 객체 표현 가능</li>
                    <li>객체를 제외한 7가지 자료형은 모두 원시 자료형</li>
                    <li>함수, 배열 모두 객체로부터 생성이 가능한 또 다른 자료형 (결국 객체다~)</li>
                </ul>
            </li>
            <li>심볼
                <ul>
                    <li>완전 유니크하고 고유한 식별자</li>
                    <li><code>const a = Symbol('hello')</code>와 <code>const b = Symbol('hello')</code>는 내용물이 같아도 <code>a !== b</code></li>
                    <li>직접 만들 일은 거의 없음, 수업에서도 잘 안다룰 예정</li>
                    <li>리액트, 리덕스 같은 남들이 만든 라이브러리를 뜯어보면 볼 수 있음</li>
                </ul>
            </li>
            <li><code>typeof</code> 연산자
                <ul>
                    <li>자료형을 문자열 형태로 반환</li>
                    <li>2가지 문법 1) 연산자 <code>typeof ...</code> 2) 함수 <code>typeof (...)</code></li>
                    <li>1) 연산자 문법 사용 예시 : <code>typeof 10 + 3 = 'number3'</code></li>
                    <li>2) 함수 문법 사용 예시 : <code>typeof (10 + 3) = 'number'</code></li>
                </ul>
                <ul>
                    <li><code>typeof Math</code> : function 아닌 object => 내장 객체이기 때문에</li>
                    <li><code>typeof null</code> : null이 아닌 object => 언어상의 오류</li>
                    <li>> null과 객체를 구분하는 방법 : <code>Object.toString()</code></li>
                    <li><code>typeof 함수</code> : function = 함수형은 따로 없지만, 하위호환성 유지를 위해 남겨짐</li>
                    <li><code>typeof [1,2,3]</code> : 배열이 아닌 object = 배열은 객체의 종류이기 때문에</li>
                    <li>> 배열인지 확인하려면 <code>Array.isArray(arr)</code> 활용</li>
                </ul>
            </li>
            <li>자스의 비밀 : 모든 자료형은 객체로 만들어졌다. 
                <ul>
                    <li><code>[[Prototype]]: Object</code> = 프로토타입 : 조상</li>
                    <li>개발자 도구에서 <code>[[Prototype]]</code>을 타고 타고 들어가면 조상은 결국 object (어.조.객)</li>
                    <li>배열의 찐조상 = <code>[[Prototype]]: Object</code></li>
                    <li>함수의 찐조상 = <code>[[Prototype]]: Object</code></li>
                    <li>문자열의 찐조상 = <code>[[Prototype]]: Object</code></li>
                    <li>> 프로토타입 확인 방법 (생성자 방식으로 문자열 생성, 아래 문단 참고) : <code>const str = new String('메롱')</code></li>
                </ul>
                <ul>
                    <li>미리보는 결론</li>
                    <li>원시형인 문자열의 조상이 객체이기 때문에(객체처럼 동작할 수 있기 때문에) 문자열에 내장객체를 호출할 수 있음</li>
                    <li>문자열에 내장객체 사용 예시 : <code>'abc'.toUpperCase()</code> = <code>객체.프로퍼티키/메서드</code></li>
                    <li>결국 모든 자료형은 객체이기 때문에 객체 문법을 사용할 수 있는 것</li>
                </ul>
                <ul>
                    <li>문자열을 생성할 수 있는 2가지 방식</li>
                    <li>1️⃣ string constructor 생성자 방식 <code>const duouble = new String('a') </code></li>
                    <li>> class (객체지향 프로그래밍)과 관련</li>
                    <li>2️⃣ string literal 문자 리터럴 방식 <code>const duouble = 'a'</code></li>
                    <li>> 매번 생성자 방식으로 변수 설정 힘드니까 스트링 리터럴 방식 많이 사용 및 권장</li>
                    <li>> 편의상 만든 문법으로, 내용물 열거는 불가함</li>
                    <li>2가지 방식의 결과는 동일하고 객체의 일환으로 만들어짐</li>
                </ul>
                <ul>
                    <li>각 조상(자료형)마다 능력이 다름 (조상 종류: 문자, 숫자, 불린, 배열, 객체, 함수)</li>
                    <li>조상이 String인 경우 : <code>includes()</code>, <code>toUpperCase()</code> 등 문자형만 사용할 수 있는 '문자형 전용 내장 객체' 사용 가능</li>
                    <li>즉 문자형는 숫자형의 능력 사용 불가</li>
                    <li>하지만 모든 자료형의 조상이 객체이기 때문에, 아래 <code>call</code> 방법을 통해 숫자의 능력을 빌려쓸 수 있음</li>
                    <li>예시) <code>Object-prototype.toString.call(123) : [object Nubmer]</code></li>
                    <li>예시) <code>Object-prototype.toString.call('a') : [object String]</code></li>
                    <li>⭐️ 따라서, 조상이 누군지 알면 조상의 능력을 맘껏 사용할 수 있고, 모든 자료형의 조상은 객체 ⭐️ </li>
                    <li>근데 이런걸 언제 쓰는디요..ㅠ : 데이터를 가공할 때</li>
                </ul>
            </li>
        </ol>
    </section>
</body>
</html>