<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>javascript - day5</title>
    <link rel="stylesheet" href="../../reset.css" />
  </head>
  <body>
    <div class="wrap">
      <h1>javascript day5</h1>
      <section>
        <h2>논리 연산자</h2>
        <ol>
          <li>
            값
            <ul>
              <li>피연산자, 연산 결과 : 모든 타입 가능</li>
              <li>피연산자가 불린형이 아니면 불린형으로 변환됨</li>
              <li>
                연산 과정에서 truthy한 값은 true로, falsy한 값은 false로 평가됨
              </li>
            </ul>
          </li>
          <li>
            || (OR) : 논리합 연산자
            <ul>
              <li>
                피연산자가 모두 false인 경우를 제외하고 연산 결과는 항상 true
              </li>
              <li><code>true || true : true</code></li>
              <li><code>true || false : true</code></li>
              <li><code>false || true : true</code></li>
              <li><code>false || false : false</code></li>
            </ul>
            <ul></ul>
          </li>
          <li>
            첫 번째 truthy를 찾는 OR 연산자 ‘||’ (⭐️)
            <ul>
              <li>
                <code>result = value1 || value2 || value3</code>
              </li>
              <li>
                왼쪽에서 오른쪽으로 나아가면서 피연산자 평가, 피연산자를
                불린형으로 평가
              </li>
              <li>
                가장 첫번째 truthy한 값을 찾고, 찾으면 연산을 즉시 멈추고
                <strong>변환 전 원래 값</strong>을 반환함
              </li>
              <li>만약 모든 값이 false라면? 마지막 피연산자 반환</li>
            </ul>
            <ul>
              <li>
                <code>result = true || true || false</code> : 첫번째 true의 원래
                값 반환
              </li>
              <li>
                <code>result = false || true || true</code> : 두번째 true의 원래
                값 반환
              </li>
              <li>
                <code>result = false || false || false</code> : 마지막 false
                원래 값 반환
              </li>
            </ul>
            <ul>
              <li><code>result = null || 1</code> : 1 반환</li>
              <li><code>result = null || 0 || 1</code> : 1 반환</li>
              <li><code>result = undefined || null || 0</code> : 0 반환</li>
            </ul>
            <ul>
              <li>
                단락평가 : truthy값을 만나면 나머지 값 보지도 않고 평가 즉시
                스탑 ~
              </li>
              <li>
                <code>true || alert("not printed")</code> : alert 실행 안됨
              </li>
            </ul>
          </li>
          <li>
            && (AND) : 논리곱 연산자 - 꼬여있는 곱창으로 기억하삼
            <ul>
              <li>피연산자가 모두가 참일 때 true를 반환</li>
            </ul>
          </li>
          <li>
            첫 번째 falsy를 찾는 AND 연산자 ‘&&’ (⭐️)
            <ul>
              <li>
                가장 첫번째 falsy한 값을 찾고, 찾으면 연산을 즉시 멈추고
                <strong> 변환 전 원래 값</strong>을 반환함
              </li>
              <li>만약 모든 값이 true라면? 마지막 피연산자 반환</li>
            </ul>
            <ul>
              <li><code>( 1 && 0 )</code> false인 0 반환</li>
              <li><code>( 1 && 5 )</code> 모두 true라서 마지막 true값 반환</li>
            </ul>
            <ul>
              <li>우선순위 : <code>&&</code> > <code>||</code></li>
              <li>
                코자 : if를 ||나 &&로 대체하지 마세요 - 하지만 실제 많이 사용함
                ㅎㅎ;
              </li>
              <li>
                > if문은 값이 반환되지 않지만 &&는 반환하기 때문에 자주 사용함
              </li>
              <li>
                > 리액트 예시 :
                <code>data && &lt;Compnent /></code>
              </li>
            </ul>
          </li>
          <li>
            ! (NOT)
            <ul>
              <li>피연산자를 불린형으로 변환 후 변환된 값을 역반환</li>
              <li><code>!null</code> : true</li>
              <li><code>!!null</code> : false</li>
            </ul>
          </li>
          <li>
            예제 풀기
            <ul>
              <li>논리합 연산자 : 가장 첫번째 truthy값 찾기</li>
              <li>
                <code>alert( alert(1) || 2 || alert(3) )</code>
              </li>
              <li>
                결과 : 얼럿 1 실행 > undeifned 리턴, false로 평가됨 > 얼럿 2
                실행 (종료)
              </li>
              <li>함수는 값을 반환하는가? yes (⭐️)</li>
              <li>어떤 값을? 리턴문이 없다면 undefined</li>
            </ul>
            <ul>
              <li>
                <code
                  >let whichTruthy = false || '' || [2,3].length ||
                  {thisIsTruthy: true}</code
                >
              </li>
              <li><code>whichTruthy = 2</code></li>
              <li>Boolean({thisIsTruthy: true}) : true</li>
              <li>2가 truthy한 값이기 때문에 즉각 스탑 후 '2' 반환</li>
            </ul>
            <ul>
              <li>논리곱 연산자 : 가장 첫번째 falsy값 찾기</li>
              <li><code>alert( alert(1) && alert(3) )</code></li>
              <li>얼럿 1 > 얼럿 undefined (종료)</li>
              <li><code>alert( undefined && alert(3) )</code></li>
              <li>얼럿 undefined (종료)</li>
            </ul>
            <ul>
              <li>
                <code
                  >let whichFalsy = true && ' ' && [] && {thisIsFalsy:
                  false}</code
                >
              </li>
              <li>
                <code>whichFalsy = {thisIsFalsy: false}</code>
              </li>
              <li>모두 true이기 때문에 마지막 값 반환됨</li>
              <li>Boolean([]) : true</li>
              <li>Boolean({}) : true</li>
            </ul>
          </li>
          <li>
            논리합 할당 연산자 logical OR assignment
            <ul>
              <li><code>a = a || b</code></li>
              <li><code>a ||= b</code></li>
            </ul>
          </li>
          <li>
            논리곱 할당 연산자 logical AND assignment
            <ul>
              <li><code>a = a && b</code></li>
              <li><code>a &&= b</code></li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>switch문</h2>
        <ol>
          <li>특정 변수를 다양한 상황에서 비교할 때 활용</li>
          <li>
            문법
            <ul>
              <li>하나 이상의 case문으로 구성</li>
              <li>default : else문 = 값과 일치하는 경우가 없다면 실행됨</li>
              <li>
                [break] : 대괄호 표시는 옵션을 의미함, 없다면 조건부합 여부와
                관계없이 이어지는 case 모두 실행
              </li>
              <li>함수 내에서 사용할 경우, return문으로 break 대체 가능</li>
            </ul>
          </li>
          <li>
            if문과의 차이점
            <ul>
              <li>switch문 : 해당하는 조건만 확인하면됨</li>
              <li>if문 : 모든 조건을 순차적으로 확인해야함</li>
              <li>따라서 조건이 너 ~ 무 많아지면 switch 케이스가 더 효율적</li>
              <li>3만개 정도 되면 성능 차이 실감남 ㅎ;</li>
            </ul>
            <ul>
              <li>switch문은 일치(===)로만 비교함</li>
              <li>if문은 일치(===), 동등(==) 비교 가능</li>
              <li>따라서 switch문은 자료형이 매우 중요함</li>
            </ul>
          </li>
          <li>
            주의점
            <ul>
              <li>switch/case문 인수에는 어떤 표현식이든 올 수 있음</li>
              <li><code>switch (+a)</code></li>
              <li><code>case a || b</code></li>
            </ul>
          </li>
          <li>
            여러 개의 "case"문 묶기
            <ul>
              <li>
                break문이 없다면, break문을 만날 때까지 코드가 계속 실행됨
              </li>
            </ul>
          </li>
          <li>
            함수 엿보기
            <ul>
              <li><code>getDay( getRandom() )</code></li>
              <li>getRandom() : 인수 argument</li>
              <li>getDay(number) - number : 매개변수, 인자 parameter</li>
              <li>getDay가 실행될 때마다 getRandom 함수도 계속 실행됨</li>
            </ul>
            <ul>
              <li>
                만약 이렇게 num를 받는다면? <code>const num = getRandom()</code>
              </li>
              <li>
                getRandom은 전역 실행환경이 만들어질 때 최초 1회만 실행되기
                때문에, 한번 정해진 숫자가 함수를 여러번 실행해도 고정됨
              </li>
            </ul>
            <ul>
              <li>
                함수를 재사용하기 위해선 매개변수 활용 필요 : getRandom(10)
              </li>
              <li>관심사의 분리(separation of concerns)</li>
              <li>
                랜덤으로날짜받아와주말리턴함수 > 1) 랜덤함수 2) 요일함수 3)
                주말함수
              </li>
              <li>1함수 1기능 지향</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>nullish 병합 연산자 '??'</h2>
        <ol>
          <li>
            문법
            <ul>
              <li>
                여러 피연산자 중 그 값이 ‘확정 되어있는’ 변수를 찾을 수 있음
              </li>
              <li><code>a ?? b</code></li>
              <li>
                a가 null도 아니고 undefined도 아닌 확정된 값이면 a, 그 외의
                경우는 b
              </li>
              <li>
                없다면 이렇게 써야함
                <code>x = (a !== null && a !== undefined) ? a : b</code>
              </li>
              <li>
                기본값을 지정할 때 주로 사용함 예시)
                <code>height = height ?? 100</code>
              </li>
            </ul>
          </li>
          <li>
            '??'와 '||'의 차이
            <ul>
              <li>|| : 첫 번째 truthy한 값을 반환</li>
              <li>
                ?? : 첫 번째 정의된 값을 반환(true, false 여부는 중요하지 않음)
              </li>
              <li><code>height = 0</code>인 경우 => 0으로 '정의함'</li>
              <li>
                <code>height || 100</code> : 100 (첫번째 truthy한 값 반환)
              </li>
              <li><code>height ?? 100</code> : 0 (첫번째 정의된 값 반환)</li>
            </ul>
          </li>
          <li>
            연산자 우선순위
            <ul>
              <li>
                <code>대부분의 연산자</code> > <code>??</code> >
                <code>=, ?</code>
              </li>
            </ul>
            <ul>
              <li>괄호 없이 ??를 ||나 &&와 함께 사용하는 것은 금지</li>
              <li>
                <code>let x = 1 && 2 ?? 3</code> : SyntaxError: Unexpected token
                '??'
              </li>
              <li><code>let x = (1 && 2) ?? 3</code> : 가능</li>
            </ul>
          </li>
          <li>
            ?. : 옵셔널 체이닝
            <ul>
              <li>
                앞의 평가 대상이 undefined나 null이면 평가를 중단하고 undefined
                반환
              </li>
              <li>주로 객체의 속성에 안전하게 접근하기 위해서 사용함</li>
              <li>null, undefined를 막는 방패</li>
              <li>
                예시) prompt 입력값을 toLowerCase() 하려고 하는데 입력값이
                없어서 null이 반환되는 경우 사용
              </li>
              <li><code>const userName = prompt('누구쇼?');</code></li>
              <li>
                <code>if( userName?.toLowerCase() === 'admin' ){ ... }</code>
              </li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>while과 for 반복문</h2>
        <ol>
          <li>
            ‘while’ 반복문
            <ul>
              <li>반복을 할 수 있는 가장 간단한 방법</li>
              <li><code>while (조건){본문}</code></li>
              <li>
                브라우저는 이런 무한 반복을 멈추게 해주는 실질적인 수단을 제공 :
                하지만 렉걸린 것처럼 보여짐
              </li>
              <li>무한루프 탈출 필승법 : 최대한 빨리 닫기 버튼 ㄱ</li>
              <li><code>while (i < 3) { i++; }</code> : i는 3</li>
            </ul>
          </li>
        </ol>
      </section>
    </div>
  </body>
</html>
