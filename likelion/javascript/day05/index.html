<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>javascript - day5</title>
    <link rel="stylesheet" href="../../reset.css" />
  </head>
  <body>
    <div class="wrap">
      <h1>javascript day5</h1>
      <section>
        <h2>논리 연산자</h2>
        <ol>
          <li>피연산자 모든 타입 가능, 연산 결과 역시 모든 타입 가능</li>
          <li>
            || (OR)
            <ul>
              <li>논리합 연산자</li>
              <li>
                피연산자가 모두 false인 경우를 제외하고 연산 결과는 항상 true
              </li>
              <li><code>true || true : true</code></li>
              <li><code>true || false : true</code></li>
              <li><code>false || true : true</code></li>
              <li><code>false || false : false</code></li>
            </ul>
            <ul>
              <li>피연산자가 불린형이 아니면 불린형으로 변환됨</li>
              <li>연산 과정에서 숫자 1은 true로, 숫자 0은 false</li>
            </ul>
          </li>
          <li>
            첫 번째 truthy를 찾는 OR 연산자 ‘||’
            <ul>
              <li>리액트 코드 읽는 아주 중요함 !! 집중 !!</li>
              <li>
                <code>result = value1 || value2 || value3</code>
              </li>
              <li>
                왼쪽에서 오른쪽으로 나아가면서 피연산자 평가, 피연산자를
                불린형으로 평가
              </li>
              <li>
                value1, 2, 3 중에 하나라도 true라면 연산을 즉시 멈추고 (단락
                평가)
                <strong>변환 전 원래 값</strong>을 반환 (⭐️)
              </li>
              <li>true로 평가된 원래 값이 result 변수에 담김</li>
              <li>만약 value 1,2,3이 모두 false라면? 마지막 피연산자 반환</li>
            </ul>
            <ul>
              <li>
                <code>result = true || true || false</code> : 첫번째 true 원래
                값 반환
              </li>
              <li>
                <code>result = false || true || true</code> : 두번째 true 원래
                값 반환
              </li>
              <li>
                <code>result = false || false || false</code> : 마지막 false
                원래 값 반환
              </li>
            </ul>
            <ul>
              <li>
                OR "||" 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를
                반환
              </li>
              <li>피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환</li>
              <li><code>result = null || 1</code> : 1 반환</li>
              <li><code>result = null || 0 || 1</code> : 1 반환</li>
              <li><code>result = undefined || null || 0</code> : 0 반환</li>
            </ul>
            <ul>
              <li>단락평가</li>
              <li>truthy값을 만나면 나머지 값 보지도 않고 평가 즉시 스탑 ~</li>
              <li>
                <code>true || alert("not printed")</code> : alert 실행 안됨
              </li>
            </ul>
          </li>
          <li>
            && (AND)
            <ul>
              <li>논리곱 연산자 (꼬여있는게 곱창같잔~)</li>
              <li>두 피연산자가 모두가 참일 때 true를 반환</li>
            </ul>
          </li>
          <li>
            첫 번째 falsy를 찾는 AND 연산자 ‘&&’
            <ul>
              <li>
                왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가
              </li>
              <li>
                변환 후 값이 false이면 평가를 멈추고 해당 피연산자의 변환 전
                원래 값을 반환 (⭐️)
              </li>
              <li>
                모두가 평가되는 경우(모든 피연산자가 true로 평가되는 경우)엔
                마지막 피연산자가 반환
              </li>
            </ul>
            <ul>
              <li><code>( 1 && 0 )</code> false인 0 반환</li>
              <li><code>( 1 && 5 )</code> 모두 true라서 마지막 true값 반환</li>
            </ul>
            <ul>
              <li>&& 우선순위 > || 우선순위</li>
              <li>if를 ||나 &&로 대체하지 마세요 : 실제 많이 사용함 ㅎㅎ;</li>
              <li>
                > if문은 값이 반환되지 않지만 &&는 반환하기 때문에 자주 사용함
              </li>
              <li>
                > 리액트 예시 :
                <code>data && <Compnent /></code>
              </li>
            </ul>
          </li>
          <li>
            ! (NOT)
            <ul>
              <li></li>
            </ul>
          </li>
          <li>
            예제 풀기
            <ul>
              <li>
                <code>alert( alert(1) || 2 || alert(3) )</code>
              </li>
              <li>
                <code>alert( undefined || 2 || alert(3) )</code>
              </li>
              <li>함수는 값을 반환하는가? yes (⭐️)</li>
              <li>어떤 값을? 리턴문이 없다면 undefined</li>
            </ul>
            <ul>
              <li><code>alert( alert(1) && alert(3) )</code></li>
              <li><code>alert( undefined && alert(3) )</code></li>
              <li>얼럿창에 undefined 찍힘</li>
            </ul>
            <ul>
              <li>
                <code
                  >let whichFalsy = true && ' ' && [] && {thisIsFalsy:
                  false}</code
                >
              </li>
              <li>
                <code>whichFalsy = {thisIsFalsy: false}</code>
              </li>
              <li>Boolean([]) : true</li>
              <li>Boolean({}) : true</li>
            </ul>
            <ul>
              <li>
                <code
                  >let whichTruthy = false || '' || [2,3].length ||
                  {thisIsTruthy: true}</code
                >
              </li>
              <li><code>whichTruthy = 2</code></li>
              <li>Boolean({thisIsTruthy: true}) : true</li>
              <li>2가 형변환 true이기 때문에 즉각 스탑 후 '2' 리턴</li>
            </ul>
          </li>
          <li>
            논리합 할당 연산자 logical or assignment
            <ul>
              <li><code>a = a || b</code></li>
              <li><code>a ||= b</code></li>
            </ul>
          </li>
          <li>
            논리곱 할당 연산자 logical or assignment
            <ul>
              <li><code>a = a && b</code></li>
              <li><code>a &&= b</code></li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>switch문</h2>
        <ol>
          <li>
            문법
            <ul>
              <li>하나 이상의 case문으로 구성</li>
              <li>default : else문</li>
              <li>
                [break] : 대괄호 표시는 옵션을 의미함, 없다면 조건부합 여부와
                관계없이 이어지는 case 모두 실행
              </li>
              <li>함수 내에서 사용할 경우, return문으로 break 대체 가능</li>
            </ul>
          </li>
          <li>
            if문과의 차이점
            <ul>
              <li>if문 : 모든 조건을 순차적으로 확인해야함</li>
              <li>switch문 : 해당하는 조건만 확인하면됨</li>
              <li>
                따라서 else if 조건이 너~무 많아지면 switch 케이스가 더 효율적
                (3만개 정도 되면 성능 차이 실감남 ㅋㅋ)
              </li>
            </ul>
          </li>
          <li>
            주의점
            <ul>
              <li>switch/case문 인수에는 어떤 표현식이든 올 수 있음</li>
              <li><code>switch (a || b)</code></li>
              <li><code>case a || b</code></li>
              <li>if문은 안됨요</li>
            </ul>
          </li>
          <li>
            여러 개의 "case"문 묶기
            <ul>
              <li></li>
            </ul>
          </li>
          <li>
            함수 엿보기
            <ul>
              <li><code>getDay( getRandom() )</code></li>
              <li>getRandom() : 인수 argument</li>
              <li>getDay(number) : 인자, 매개변수 parameter</li>
              <li>getDay가 실행될 때마다 getRandom 함수도 계속 실행됨</li>
            </ul>
            <ul>
              <li>
                만약 이렇게 num를 받는다면? <code>const num = getRandom()</code>
              </li>
              <li>
                getRandom은 전역 실행환경이 만들어질 때 최초 1회만 실행되기
                때문에, 한번 정해진 숫자가 함수를 여러번 실행해도 고정됨
              </li>
            </ul>
            <ul>
              <li>함수를 재사용하기 위해선 매개변수 활용 필요 : getRandom(10)</li>
              <li>관심사의 분리(separation of concerns) : 랜덤으로날짜받아와주말리턴함수 > 1) 랜덤함수 2) 요일함수 3) 주말함수</li>
              <li>1함수 1기능</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>nullish 병합 연산자 '??'</h2>
        <ol>
          <li>문법
            <ul>
              <li>여러 피연산자 중 그 값이 ‘확정 되어있는’ 변수를 찾을 수 있음</li>
              <li><code>a ?? b</code></li>
              <li>a가 null도 아니고 undefined도 아니면 a</li>
              <li>그 외의 경우는 b</li>
              <li>?? 없다면 이렇게 써야함 <code>x = (a !== null && a !== undefined) ? a : b;</code></li>
              <li>기본값을 지정할 때 주로 사용함</li>
            </ul>
          </li>
          <li>'??'와 '||'의 차이
            <ul>
              <li>|| : 무조건 첫번째 truthy한 값을 찾음</li>
              <li>?? : 사용자가 임의로 정의한 값을 찾음(true, false 여부는 중요하지 않음)</li>
              <li><code>height = 0</code>인 경우 = 0으로 정의함</li>
              <li><code>height || 100</code> : 100</li>
              <li><code>height ?? 100</code> : 0</li>
            </ul>
          </li>
          <li>연산자 우선순위
            <ul>
              <li>괄호 없이 ??를 ||나 &&와 함께 사용하는 것은 금지</li>
            </ul>
          </li>
          <li>?. : 옵셔널 체이닝
            <ul>
              <li>보다 작은 개념 음.. !</li>
            </ul>
          </li>
        </ol>
      </section>
      <section>
        <h2>while과 for 반복문</h2>
        <ol>
          <li>‘while’ 반복문
            <ul>
              <li>반복을 할 수 있는 가장 간단한 방법</li>
              <li><code>while (조건){본문}</code></li>
              <li>브라우저는 이런 무한 반복을 멈추게 해주는 실질적인 수단을 제공 : 하지만 렉걸린 것처럼 보여짐</li>
              <li>무한루프 탈출 필승법 : 최대한 빨리 닫기 버튼 ㄱ</li>
              <li><code>while (i < 3) { i++; }</code> : i는 3</li>
            </ul>
          </li>
        </ol>
      </section>
    </div>
  </body>
</html>
